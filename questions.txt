Q: Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах. Какие есть способы применения знаний о фазах распространения событий на практике?
A: 
Event Propagation механизм, который определяет порядок обработки события, которое произошло на элементе DOM. Event Propagation включает в себя 3 фазы: Capture, Targer и Bubbling. 
Capture - Событие начинает "опускаться" от корневого элемента DOM до объекта на котром произошло событие.
Target - Событие достигает и обрабатывается обработчиками на целевом элементе (элемент где произошло событие).
Bubbling - Событие начинает "подниматься" от целевого элемента до корня DOM. 

В основном механизм Event Propagation используется для реализации приема "делегирование". Например, можно зарегистрировать обработчик событий на одном элементе и перехватывать все события, которые происходят на дочерних элементах.
Еще одним примером применения Event Propagation является переопределение действий бразуера по умолчанию. Например, мы используем event.preventDefault() на обработчике onclick ссылки, для того чтобы предотвратить переход по ссылке.

Q: Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?
A: 
Promise - это объект, который представляет результат выполнения асинхронной операции. Может находится в одном из трех состояний: Pending, Fulfilled, Rejected. Переход состояний однонаправленный, т.е. Pending -> Fulfilled или Pending -> Rejected.
Альтернативами использования Promise может быть подход, связанный с использованием обратных вызовов или использование синтаксического сахара над Promise - async/await.

Event Loop обеспечивает неблокирующую работу JS кода, включая синхронные и асинхронные задачи. Event Loop планирует асинхронные задачи в очередях микро (например, Promise) и макро-задач(например, setTimeout, setInterval) 
так, чтобы асинхронные задачи, которые еще не выполнены и не могу вернуть результат не блокировали main thread.  

Q: Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том, как ООП реализовано в JavaScript
A: 
ООП парадигма програмирования, в которой программа организована как совокупность объектов, взаимодействующих друг с другом. ООП включает три основынх приницпа:
Инкапсуляция - Детали реализации не должны "протекать" во внешний код, объекты должны предоставлять наружу только те методы или данные, которые ныжны для взаимодействия с объектом.  
Наследование - Создание новых классов на основе существующих с возможностью переиспользования и расширения функциональности.
Полиморфизм - Объекты с одним интефейсом могут иметь разную реализацию.

В JS принципы ООП реализуются так:
Наследование - в JS реализовано протоипное наследование или Prototype Chain. Объекты в JS имеют внутреннее поле [[Prototype]] которые ссылается на класс-родитель. Поиск свойств и методов реализован так, что сначала ищется метод или свойство внутри самого объекта, далее у его прототипа  и т.д. пока не будет найдено или вернется undefined. 
Инкапсуляция - в JS много механизмов, которые так или иначе реализуют инкапсуляцию, например, приватные поля классов, замыкание или дескрипторы свойств.
Полиморфизм - в JS достигается через переопределение методов в цепочке прототипов. Когда вызывается метод объекта, будет использован первый найденный метод по цепочке прототипов - это позволяет подклассу переопределить поведение базового класса.

Q: Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопастность, междоменное взаимодействие) могут возникать в процессе?
A: 
1. Интерпретация URL (может добавить протокол, декодирование и приведение порта по умолчанию)
2. DNS-резолвинг, проверка локального кэша DNS и далее до DNS-провайдера. Получаем IP.
3. Установка TCP/TLS соединения. TCP hanshacke + TLS handshacke (если https). Тут проверяется, что соединение может быть установлено и при https происходит обмен ключами и сервтификатом для шифровки трафика.
4. Отправка HTTP запросов
5. Получение HTML 
6. Хагрузка файлов стилей, скриптов, ресурсов
7. Выполнение Critical Rendering Path (DOM + CSSOM, Render tree, Layout, Paint, Compositing)
8. Выполнение JS скриптов

Привожу некоторые средства оптимизации, т.к. их очень много и каждый этап использует свои:
gzip - уменьшение объёма передаваемых данных.
Critical CSS - уменьшение критического path.
CDN - размещение статики на edge серврах ближе к пользоваелю
HTTP/2 / HTTP/3 - сжатие, больше активных соединений.
preload, prefetch, prerender - раннее выполнении сетевых действий (загрузка ресрурсов).



